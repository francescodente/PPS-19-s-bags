\section{Implementazione}

% questa sezione deve essere sufficiente per uno sviluppatore per avere una implementazione, essenzialmente equivalente alla nostra

% (per ogni studente, una sotto-sezione descrittiva di cosa fatto/co-fatto e con chi, e descrizione di aspetti implementativi importanti non già presenti nel design)


% L'implementazione "esplode" il design, ma solo laddove pensiate che serva dire qualcosa.

% Cercate di dare una idea di quanto pensate che i vostri test automatizzati coprano il codice e dove: è importante per stimare il potenziale impatto di una modifica al software.

%Scaletta:
%Setup ed esecuzione dei giochi (Program lifecycle su trello)

% - Cli
Data l'infrastruttura di gestione dell'interazione con il giocatore, un utente della libreria può scegliere se scrivere una propria implementazione dell'interfaccia grafica oppure se avvalersi dell'interfaccia a riga di comando fornita dalla libreria.
%
Questa opzione è compatibile solamente con i giochi aventi una \textit{Board} \textbf{rettangolare}, per tutti gli altri è necessario fornire un'implementazione alternativa.

% Generazione automatica
L'interfaccia a riga di comando è generata a partire dalle caratteristiche del gioco e dai \texttt{Renderer} associati, seguendo così un approccio standardizzato per associare a diverse \textbf{estensioni} del gioco una rappresentazione in maniera automatica.
%
% personalizzazione grafica
Ciò consente di avere una visualizzazione semplice del gioco scritto usando la libreria con il minimo sforzo da parte dell'utente, che ha però la possibilità di personalizzare la grafica fornendo una serie di parametri oppure nuove implementazioni dei singoli componenti per i quali desidera un aspetto diverso.
%
In particolare gli aspetti personalizzabili per il \texttt{BoardRenderer} sono:
\begin{itemize}
  \item Rappresentazione degli indici delle colonne;
  \item Rappresentazione degli indici delle righe;
  \item Separatore degli elementi grafici;
  \item Terminazione riga;
  \item Rappresentazione dei \textit{Tile} vuoti;
  \item Rappresentazione dei diversi \textit{Pawn}.
\end{itemize}
%
Ognuno di questi parametri ha un valore di default, seguendo il principio della \textbf{convenzione} prima della \textbf{personalizzazione} in modo da snellire il processo di preparazione dell'interfaccia da parte dell'utente qualora le impostazioni base fossero sufficienti.
%
Infine, i \texttt{Renderer} rimanenti non sono parametrici in quanto sufficientemente semplici da poter essere completamente sostituiti in maniera rapida da nuove implementazioni.

%DSL

%Estensioni
\subsection{Estensioni}
%
Ogni \texttt{extension} definisce una diversa caratteristica di un \textit{Game}.
%
Le \texttt{extension} innestabili all'interno di un \textit{Game} sono:
\begin{itemize}
  \item l'esistenza di una \textit{Board} con il relativo \textit{State};
  \item l'esistenza di una \texttt{condizione di terminazione} che porta ad un \textit{risultato} del \textit{Game};
  \item l'esistenza dei \textit{turni} per scandire lo sviluppo di gioco;
  \item l'esistenza dei \textit{giocatori} con la possibilità di gestirne l'alternanza dei \textit{turni}.
\end{itemize}
%
Dato che ogni \textit{Game} può presentare diverse \texttt{extension}, è necessario che ognuna di queste sia inseribile opzionalmente nel \textit{Game} e facile da definire.
%
Viste queste premesse, le \texttt{extension} sono state espanse a loro volta tramite le \texttt{implicit class} di scala: questo per rendere più leggibile il codice in cui vengono utilizzate.
%

%Example (giochi)
\subsection{Giochi}
Oltre alla libreria stessa sono stati sviluppati alcuni giochi per fungere da esempi per gli utenti e dimostrare l'utilizzo delle funzionalità proposte.
%
Per realizzare un gioco utilizzando la libreria è necessario definire i \textit{Pawn}, le \textit{Move}, la \textit{Board} e lo \textit{State}.% lo state è dinamico
%
Solitamente questo viene fatto tramite \texttt{Trait}, \texttt{Case Class} e \texttt{Case Object}.
%
La fase successiva prevede, in un qualsiasi ordine, di definire:
\begin{itemize}
  \item la \texttt{GameDescription}, come \texttt{object} che estende \texttt{GameDescription}, dove sono dichiarati gli \texttt{implicit} necessari al funzionamento delle \texttt{extension};
  \item il \textit{RuleSet}, che consiste in un \texttt{object} che estende il \texttt{RuleSet} e può essere descritto tramite il \textbf{DSL} se \textbf{mixato} con il \texttt{RuleSetBuilder}
\end{itemize}

Infine è necessario sviluppare un \textbf{main} che sia in grado di eseguire l'applicazione così definita.
%
Per fare ciò ci si può avvalere del \texttt{GameSetup}, o più in particolare del \texttt{CliGameSetup} se si vuole usufruire della cli già fornita, dove vengono definiti i \texttt{Renderer} ed i parametri del \textbf{controller}.
%
Dato un \texttt{GameSetup} è possibile eseguire il gioco semplicemente utilizzando l'\texttt{AppRunner}.

%Divisione del lavoro
\subsection{Divisione del lavoro}
%parti comuni:
% - core
% - extension
% - divisione in due sottogruppi per la gestione delle due macro-componenti del progetto
% -- Comuni: RuleSet, DSL, Features

\subsubsection{Dente Francesco}
% dsl in comune con Evangelisti
% - chainables
% - moves generation
% game setup
% type class
% othello

\subsubsection{Evangelisti Davide}
% dsl in comune con Dente, RuleSet (con particolare attenzione alla move execution e le Action), PutInPutOut Revisited, 'after each move', RuleSetBuilder
% RuleSetBuilder
% MovesExecution

\subsubsection{Magnani Simone}
% interaction in comune con Nemati. In singolo:
% View - GameView
% renderer
% Connect4

\subsubsection{Nemati Shapour}
% interaction in comune con Magnani. In singolo:
% Controller
% Event
% Input parser
% Rectangular Board
% Tic-Tac-Toe

%Testing
\subsection{Testing}
I test effettuati sul codice sviluppato hanno lo scopo principalmente di garantire la qualità del codice, di favorire il cambiamento ed infine di documentazione del software sviluppato, seguendo la \textbf{quality school} e la \textbf{agile school} come filosofie di riferimento.
%
Avendo approcciato il progetto con la metodologia \textbf{TDD} la maggior parte del codice risulta avere degli unit test che coprono le singole funzionalità.
%
Ci sono alcune eccezioni, ad esempio l'interfaccia testuale risulta essere poco coperta dai test a causa della necessità di acquisire input da tastiera e la scarsa utilità di testare i risultati di stampe a video.
%
La copertura risulta invece molto alta nel \texttt{model}, arrivando ad avere il 100\% di coverage per il \texttt{core}.
%
Oltre agli \textbf{unit test} utilizzati per l'approccio TDD e sviluppati prima del codice stesso, sono presenti anche degli \textbf{integration test}, aggiunti una volta terminato lo sviluppo del codice di una singola unità per assicurare la corretta interazione con le altre.
%
Infine, i \textbf{system test} sono stati effettuati nei giochi d'esempio, che forniscono un ambiente articolato e completo dove poter testare l'interazione fra i diversi moduli del sistema.
%

\subsubsection{Test doubles}
Ove possibile sono stati effettuati test di tipo funzionale e \textbf{blackboxed}, mentre dove è risultato necessario sono stati effettuati dei test strutturali \textbf{whiteboxed}.
%
Entrambi le casistiche hanno visto un impiego frequente dei \textbf{test doubles} sfruttando la libreria \textbf{scalamock} per rimuovere le dipendenze dagli unit test o per verificare il comportamento interno di un componente nel caso di test whitebox.

\subsubsection{Stile dei test}
Lo stile adottato è stato \textbf{FlatSpec} nella quasi totalità dei casi, in quanto il più adatto agli unit test e semplice sia da consultare che da modificare, a favore di uno sviluppo agile del software a fronte di cambiamenti nei requisiti o nella loro comprensione da parte del team.