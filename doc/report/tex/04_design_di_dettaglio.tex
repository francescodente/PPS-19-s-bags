\section{Design di dettaglio}

%(scelte rilevanti, pattern di progettazione, organizzazione del codice -- corredato da pochi ma efficaci diagrammi)

%Il design di dettaglio "esplode" (dettaglia) l'architettura, ma viene concettualmente prima dell'implementazione, quindi non metteteci diagrammi ultra-dettagliati estratti dal codice, quelli vanno nella parte di implementazione eventualmente.

% Estensioni dello stato tramite type class
% Concetti del DSL (?)
% - usato per MoveGeneration/MoveExecution
% - MoveGeneration usano generators
% - MoveExecution usano actions
% - modifiers per eseguire costrutti iterativi/condizionali e che si basano sui chainables (type class) per astrarre il modo in cui vengono eseguite le iterazioni/condizioni
% - feature (per accedere allo stato nonostante il ruleset sia definito a livello intensionale e quindi non ha accesso a uno stato particolare)
\subsection{RuleSet e Dsl}

Si va ora ad analizzare il desing di dettaglio relativo al \textit{RuleSet} e al suo \textit{Dsl}.

Il \textit{RuleSet} idendifica l'insieme delle regole che definiscono se, in un determinato stato, una \textit{move} è valida e in quale modo questa modifichi lo stato del gioco al momento della sua esecuzione.
% TODO da rivedere
Per separare la logica del \textit{RuleSet} dalle componenti che devono occuparsi della sua creazione si è fatto ricorso ad un builder \texttt{RuleSetBuilder}, \textit{un Self-type and mixins}, che funge da coordinatore per raggruppare i vari elementi della generazione del \textit{ruleSet}.

\paragraph{MovesGeneration} fornisce gli strumenti per raccogliere l'insieme di tutti i generatori di \textit{move} per poi raccoglierli ed utilizzarli in ogni fase del gioco per generare la sequenza di tutte le mosse disponibili in un dato momento.

\paragraph{MovesExecution} è la componente che permette di definire in quale modo il \textit{GameState} vada aggiornato; mette a disposizione vari costrutti per aggiungere comportamenti e routine da eseguire al verificarsi di una data \textit{move} e permette, inoltre, di specificare azioni da eseguire prima e dopo l'esecuzione di mosse specifiche.

Sia \texttt{MovesGeneration} che \texttt{MovesExecution} forniscono le primitive per poter lavorare agilmente con il sistema del \textit{RuleSet}.
%
Questi però sono solamente un involucro e da soli non sono in grado di fornire una semplificazione al sistema per chi utilizzerà poi la libreria.
%
Grazie all'aggiunta di un \texttt{DSL} complesso mostrato in figura (FIGURA).

\subsection{Interaction}

Le funzionalità abilitanti l'interazione con i giocatori sono state incapsulate totalmente nel modulo \texttt{interaction}, che comprende \textbf{view} e \textbf{controller}, con un interfacciamento verso il \textbf{model}.

Un gioco completo sviluppato con la libreria prevede tre \textbf{contesti} principali:
\begin{itemize}
    \item \textit{Application}: l'intera applicazione intesa come eseguibile in funzione; % non mi piace
    \item \textit{Menu}: il punto di ingresso dell'applicazione dove poter selezionare opzioni come giocare una nuova partita oppure uscire dal programma;
    \item \textit{Game}: una partita in corso.
\end{itemize}

L'utente potrà interagire con il programma in maniera diversa in base al contesto, e per garantire una buona separazione delle responsabilità ogni contesto è racchiuso in una coppia di subView e subController.

% - View
\subsubsection{View}
% - - View principale -> Gestione subview
% - - Menu view
% - - Game view
% - - - Renderers
% - - - Eventi
% - - Cli
% - Controller
\subsubsection{Controller}
% - - Application controller
% - - Menu controller
% - - Game controller
% - Game setup come entry point